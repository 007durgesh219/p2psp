<h1 id="nat-traversal-in-p2psp-protocol">NAT traversal in P2PSP protocol</h1>
<p>Information about NAT traversal in the P2PSP protocol can be found in the [P2PSP protocol documentation][1] and in [this slideshow][2]. This document documents the NAT traversal methods developed in the GSoC 2015 project “NAT traversal using UDP hole punching” as a python implementation in the NAT Traversal Set of rules (NTS) classes.</p>
<h1 id="nat-types">NAT types</h1>
<p>The behaviour of different implementations of NAT devices (i.e. routers), can be grouped into a few different NAT types. A short description from <span class="citation">Donne (1995)</span> <span class="citation">(n.d.)</span>:</p>
<ul>
<li><p><span><strong>Full-cone NAT (FCN)</strong></span>:</p>
<blockquote>
<p>“A full-cone NAT is one where all requests from the same intern al IP address and port are mapped to the same external IP address and port. Any external host can send a packet to the internal host simply by sending a packet to the mapped external address.”</p>
</blockquote></li>
<li><p><span><strong>Restricted cone NAT (RCN)</strong></span>:</p>
<blockquote>
<p>“A restricted-cone NAT is one where all requests from the same internal IP address and port are mapped to the same external IP address and port. Unlike a full-cone NAT though, an external host can send a packet to the internal host only if the internal host had previously sent a packet to that external host.”</p>
</blockquote></li>
<li><p><span><strong>Port-restricted cone NAT (PRCN)</strong></span>:</p>
<blockquote>
<p>“A port-restricted cone NAT is like a restricted-cone NAT, but the restriction also includes port numbers. An external host can send a packet to the internal host only if the internal host had previously sent a packet to that external host on the same port number.”</p>
</blockquote></li>
<li><p><span><strong>Symmetric NAT (SYM)</strong></span>:</p>
<blockquote>
<p>“A symmetric nat is a NAT where all requests from the same internal IP address and port to a specific destination IP address and port are mapped to the same external source IP address and port. If the same internal host sends a packet with the same source address and port to a different destination, a different mapping is used (these mappings are referred to as NAT translations). Only the external host that receives a packet can send a packet back to the internal host.”</p>
</blockquote>
<p>As described in <span class="citation">(n.d.)</span>, the symmetric NATs can be divided again into these three subtypes, depending on the allocation of the source port of the NAT:</p>
<ul>
<li><p>:</p>
<p>The public source port of the NAT is the same as the source port of the local host. If this NAT behaviour is detected, prediction of the public port is trivial.</p></li>
<li><p>:</p>
<p>To allocate a new public source port, the next free port number is selected, so the port number is incremented each time. This is described in detail below.</p></li>
<li><p>:</p>
<p>For each new pair `(dest. address, dest. port)` a completely random and therefore unpredictable public source port is selected.</p></li>
</ul></li>
</ul>
<h1 id="nat-type-determination">NAT type determination</h1>
<p>To be able to traverse a NAT device, the type of the NAT has to be determined correctly. For this, the NAT types are grouped into port preserving NAT devices (FCN, RCN, PRCN, SYMPP), and types with destination dependent port allocation (SYMSP, SYMRP). The port preserving types are not differentiated, as the NAT traversal overhead unnecessary for FCN devices is less effort than detecting the FCN type, and NAT traversal of RCN, PRCN, SYMPP can be handled equally. The randomly source port allocating type is not handled differently than the sequentially allocating type, as the allocated ports cannot be predicted and the unnecessary port prediction overhead negligible.</p>
<p>To determine the port allocation method of a new peer A, it sends UDP packets to the splitter and to the monitor peer(s), and the monitor peers forward the source ports used at the new peer to the splitter.</p>
<p>Between two packets sent by the P2PSP software, another software behind the same NAT could also send UDP packets to a new destination and the measured port distance would be higher than the actual port step of the NATs. Therefore the splitter calculates the distance between each source port used by the new peer and combines them using the greatest common divisor (GCD), to determine the port step of the NAT. Also, when a new peer B arrives and connects to the now incorporated peer A, both peers send the source port used by each other to the splitter. The splitter then calculates the distance between the source port towards itself and towards the other peer and combines the distance and the previously determined port step using GCD, for each of the peers.</p>
<p>So the more monitor peers there are in the team, the more accurately determined is the port step of a new peer before incorporating it into the team, and the more peers there are in the team, the more accurately determined is the port step of already incorporated peers.</p>
<p>If the determined port step is 0, the NAT is one of the FCN, RCN, PRCN, SYMPP types and NAT traversal is trivial. Otherwise the P2PSP software will try to predict the source ports chosen next by the NAT. See details below.</p>
<h1 id="udp-hole-punching-and-port-prediction">UDP hole punching and port prediction</h1>
<h2 id="udp-hole-punching">UDP hole punching</h2>
<p>NAT devices (all but the FCN type) only forward packets from a peer to the local network if previously a packet to the peer address and port has been sent and therefore a NAT entry exists (for RCN, a packet must have been sent to the peer address and **any** port). Therefore hello packets are sent continuously between two peers until both peers have received a packet from each other.</p>
<h2 id="source-port-prediction">Source port prediction</h2>
<p>In case peer A and B want to connect to each other and peer A is behind a NAT with a different source port for each destination, normal UDP hole punching does not work:</p>
<ol>
<li><p>Peer A sends a packet to peer B, with a randomly generated source port; a NAT entry at peer A is created.</p></li>
<li><p>The packet does not reach peer B, because there is no corresponding NAT entry at the NAT of peer B.</p></li>
<li><p>Peer B sends a packet to peer A, with the same source port as for every destination; a NAT entry at peer B is created.</p></li>
<li><p>The packet does not reach peer A, because the destination port at peer A that peer B sent to does not match the source port of the packet to peer B.</p></li>
</ol>
<p>If peer A can predict the source port that will be allocated for the packet from peer B, then peer A can send packets to this port and they will be forwarded by the NAT as a matching NAT entry exists.</p>
<h3 id="simple-port-prediction">Simple port prediction</h3>
<p>When a new peer behind a sequentially allocating NAT wants to be incorporated into the team, it sends hello packets to the splitter and to the monitors, and then to all peers, one after another. For each new destination, the allocated source port is increased by the port step of the NAT. So for a given `port_step` and a `peer_number`, the predicted source port is:</p>
<pre><code>predicted_source_port = source_port_to_splitter + peer_number * port_step</code></pre>
<h3 id="advanced-port-prediction">Advanced port prediction</h3>
<p>When during the sending of the hello packets to the peers another packet is sent by any host behind the same NAT, a source port will be allocated for that packet as well. So one port number is skipped and the following outgoint packets will have a source port `predicted_source_port + port_step`. To increase the probability that the correct source port is matched, the peers try various numbers of skips out of `<span>0,1,...</span>`, and for each the predicted source port is:</p>
<pre><code>predicted_source_port = source_port_to_splitter + (peer_number + skips) * port_step</code></pre>
<h3 id="even-more-advanced-port-prediction">Even more advanced port prediction</h3>
<p>There are a few more things to consider when predicting source ports. In the following paragraph it is assumed that the splitter has determined a port distance of 10 and the third peer tries to predict the source port of the newly arriving peer and tries 20 different ports to have good chances:</p>
<ol>
<li><p>The port step cannot be determined reliably (as stated above). If the splitter measures a port distance of 10, it could actually be one of {1,2,5,10}. So there is a measured port distance and an actual port step.</p></li>
<li><p>For each probable port step, different numbers of “skips” should be tried, because some source ports are skipped if the port is already taken by another UDP “connection”. So as the third peer is 3 port steps after the monitor, the ports {3,4,...}, {6,8,...}, {15,20,...}, {30,40,...} should be tried (in addition to `source_port_to_splitter`).</p></li>
<li><p>The number of port “skips” depends on the assumed port step: If a port step of 10 is measured but a port step of 1 is assumed, then there must have been 9 port skips between the UDP packets to the splitter and to the monitor. So it is very likely that there will be also many port skips between the packets to the peers, so different numbers of skips should be tried: {3,4,5,6,7,8}. On the other hand, if both the measured and the assumed port step are 10, then there have been no port skips and it is less likely that some will occur between the packets to the peers, so few port skips are tried: {30,40}.</p></li>
</ol>
<p>Two examples where a trivial implementation (assuming either a port step of 1 or assuming the measured port distance as the port step) would fail:</p>
<ul>
<li><p>When a port step of 1 is assumed for all NATs, and the actual port step is 10, then the predicted ports will be {3,4,...,23}, while the actual taken port is one of {30,40,...}, depending on the number of skips.</p></li>
<li><p>If the assumed port step is 10 and the actual is 1, then the predicted ports will be {30,40,...,230}, while the actual taken port is one of {3,4,...}.</p></li>
</ul>
<p>To solve this, an algorithm was developed that assumes different port steps and for each assumes different numbers of skips, and calculates probable <code>port_diffs</code> (in addition to <code>source_port_to_splitter</code>) given any determined port distance <code>port_diff</code> and <code>peer_number</code> (the position in the team of the peer that does the port prediction).</p>
<pre><code>    # Get probable port steps
    factors = self.get_factors(port_diff)
    # Estimate how many port guesses will be made
    num_combinations = self.count_combinations(factors)
    # Influence the prediction to achieve the desired number of results
    count_factor = common.MAX_PREDICTED_PORTS/float(num_combinations)

    port_diffs = sorted(set(reduce(list.__add__, (list(
        # For each previous peer and each skip, the source port is incremented
        port_step * (peer_number + skips)
        # For each assumed port_step, &quot;port_diff/port_step&quot; different port skips
        # are tried, multiplied with count_factor to get the desired list length
        for skips in range(int(math.ceil(port_diff/port_step*count_factor))+1))
        # Each factor of port_diff is a possible port_step
        for port_step in factors))))</code></pre>
<p>The desired number of results can be approximately achieved. For the example above, the algorithm yields:</p>
<pre><code>    port_diffs = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 20, 25, 0, 40, 50]</code></pre>
<h2 id="limits-for-udp-hole-punching-and-port-prediction">Limits for UDP hole punching and port prediction</h2>
<p>In some scenarios UDP hole punching with port prediction cannot work by design. When one peer is behind a port-restricted NAT (PRCN, or a symmetric NAT), it only receives messages if they come from an address/port tuple that the peer previously sent a message to. If the other peer is behind a NAT with an randomly (not sequentially) allocated source port, then the first peer cannot predict the source port of a message from the second peer and send a message to this endpoint. So a peer with port-restricted NAT and a peer with a randomly source port allocating NAT cannot send messages to each other.</p>
<p>To determine the possible combinations, the NAT types can be divided into three classes:</p>
<ol>
<li><p>Not port-restricted, with a predictable port number (FCN, RCN).</p></li>
<li><p>Port-restricted, with a predictable port number (PRCN, SYMPP, SYMSP).</p></li>
<li><p>Port-restricted, with an unpredictable port number (SYMRP).</p></li>
</ol>
<p>This assumes that all symmetric NAT implementations are port-restricted. For these three classes, the following combinations theoretically can work:</p>
<pre><code>    Peer1\2 | 1.  | 2.  | 3.
    =========================
    1.      | yes | yes | yes
    2.      | yes | yes | no
    3.      | yes | no  | no</code></pre>
<p>Using the six different NAT types, the table looks like this:</p>
<pre><code>    Peer1\2 | fcn   | rcn   | prcn  | sympp | symsp | symrp
    =========================================================
    fcn     | yes   | yes   | yes   | yes   | yes   | yes
    rcn     | yes   | yes   | yes   | yes   | yes   | yes
    prcn    | yes   | yes   | yes   | yes   | yes   | no
    sympp   | yes   | yes   | yes   | yes   | yes   | no
    symsp   | yes   | yes   | yes   | yes   | yes   | no
    symrp   | yes   | yes   | no    | no    | no    | no</code></pre>
<p>This shows that most combinations are possible, especially as according to [this paper][5] only few NAT devices are symmetric ones. However this also means that if there is already a peer behind a port-restricted NAT in the team, a peer with a randomly port allocating NAT cannot join the team at all (or vice versa).</p>
<h1 id="implementation-of-the-nat-traversal-set-of-rules">Implementation of the NAT Traversal Set of rules</h1>
<h2 id="reliable-message-sending-over-udp">Reliable message sending over UDP</h2>
<p>The P2PSP software uses TCP during initialization and incorporation of a new peer in a team. Afterwards UDP is used due to its low latency needed for live video broadcasting. As UDP is per design an unreliable protocol and packets may drop or arrive several times in any order, important data (needed for establishing connections between peers) is sent continuously in regular intervals. The receiver then sends exactly the same message as an acknowledge back to the sender:</p>
<p><img src="images/acknowledge_message.png" alt="image" /></p>
<p>The splitter has the most important role in P2PSP streaming. To reduce load on the splitter, it does not automatically resend messages continuously in a thread but only replies to peers if a message is received. To ensure that a message reaches the peer, it is sent several (currently 3) times at once:</p>
<p><img src="images/message_from_splitter.png" alt="image" /></p>
<p>The NAT traversal classes are developed in such a way that repeatedly arriving messages do not affect the communication between peers.</p>
<h2 id="symsp-source-port-update">SYMSP source port update</h2>
<p>The splitter saves the last known source port of all peers. When a new peer arrives a long time after the last peer has arrived, then this information may be out of date, if another UDP packet has been sent from any host behind the same SYMSP NAT. To retrieve the currently allocated source port of such a peer, during incorporation of a new peer all already incorporated peers with a `port_step &gt; 0` send a hello message to a new temporary UDP socket at the splitter, for which a new source port at the peers is allocated. So if the arriving peer fails to connect to one of the peers, when retrying incorporation it can rely on an up to date source port.</p>
<h2 id="nat-traversal-method">NAT traversal method</h2>
<p>The sequence of messages when a new peer is arriving and another peer has already been incorporated into the team is shown in the diagram below:</p>
<p><img src="images/NAT_traversal.png" alt="image" /></p>
<ol>
<li><p>Peer 1 already has been incorporated into the team and communicates with the splitter and monitor over UDP.</p></li>
<li><p>A new peer 2 connects to the splitter over TCP and receives the configuration as well as the public endpoints of the peers in the team, including the determined port step of the NAT of each peer.</p></li>
<li><p>Peer 2 continuously sends hello messages to the splitter and the monitor, each until an acknowledge is received.</p></li>
<li><p>The monitor forwards the hello message to the splitter, appending the source port of peer 2 towards the monitor.</p></li>
<li><p>The splitter determines the port step of peer 2 using the hello messages.</p></li>
<li><p>The splitter binds a new socket to a random port and sends address, port and determined port step of peer 2 and the port of the new socket to peer 1.</p></li>
<li><p>Peer 1 sends a hello message to the new splitter socket to determine its currently allocated source port for later peer arrivals.</p></li>
<li><p>Peer 1 and 2 start sending hello messages to each other, each for a number of predicted possible ports, until an acknowledge is received.</p></li>
<li><p>When receiving a hello message, the peers send the used source port of the other peer to the splitter to determine the port step more accurately and to save the currently allocated source port.</p></li>
<li><p>After having received a hello message from peer 1, peer 2 sends a message of success to the splitter.</p></li>
<li><p>The splitter and peer 2 close their TCP socket.</p></li>
</ol>
<p>The same principle applies if there is more than monitor or more than one already incorporated peer.</p>
<h2 id="retrying-incorporation">Retrying incorporation</h2>
<p>When a peer fails to receive hello messages from one or more incorporated peers, it retries to join the team with a new UDP socket:</p>
<p><img src="images/retrying_incorporation.png" alt="image" /></p>
<ol>
<li><p>Peer 1 already has been incorporated into the team and communicates with the splitter and monitor over UDP.</p></li>
<li><p>Peer 2 closes its UDP socket and creates a new one, to have different source ports.</p></li>
<li><p>Peer 2 sends a retry message to the splitter and the monitor, each until an acknowledge is received.</p></li>
<li><p>The splitter sends the public endpoints of the peers in the team, including the determined port step of the NAT of each peer. This is necessary as the peer list or port information could have changed since peer 2 tried to get incorporated.</p></li>
<li><p>The monitor forwards the retry message to the splitter, appending the source port of peer 2 towards the monitor.</p></li>
<li><p>The splitter determines the port step of peer 2 using the retry messages.</p></li>
<li><p>The splitter binds a new socket to a random port and sends address, port and determined port step of peer 2 and the port of the new socket to peer 1.</p></li>
<li><p>Peer 1 sends a hello message to the new splitter socket to determine its currently allocated source port for later peer arrivals.</p></li>
<li><p>Peer 1 and 2 start sending hello messages to each other, each for a number of predicted possible ports, until an acknowledge is received.</p></li>
<li><p>When receiving a hello message, the peers send the used source port of the other peer to the splitter to determine the port step more accurately and to save the currently allocated source port.</p></li>
<li><p>After having received a hello message from peer 1, peer 2 sends a message of success to the splitter.</p></li>
<li><p>The splitter and peer 2 close their TCP socket.</p></li>
</ol>
<p>As above, the same principle applies if there is more than monitor or more than one already incorporated peer.</p>
<p>After the splitter has received a message of success, a peer cannot retry incorporation anymore. This is to ensure that an attacker cannot disturb the communication of a peer once it is incorporated into the team.</p>
<div id="refs" class="references">
<div id="ref-test">
<p>Donne, John. 1995. <em>The Variorum Edition of the Poetry of John Donne</em>. Edited by Gary A. Stringer. Vol. 6. Bloomington: Indiana Univ. Press.</p>
</div>
<div id="ref-NAT-traversal-testing">
<p>n.d. <a href="https://wiki.asterisk.org/wiki/display/TOP/NAT+Traversal+Testing" class="uri">https://wiki.asterisk.org/wiki/display/TOP/NAT+Traversal+Testing</a>.</p>
</div>
<div id="ref-Takeda">
<p>n.d. <a href="https://tools.ietf.org/id/draft-takeda-symmetric-nat-traversal-00.txt" class="uri">https://tools.ietf.org/id/draft-takeda-symmetric-nat-traversal-00.txt</a>.</p>
</div>
</div>
